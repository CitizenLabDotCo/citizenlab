# EmailCampaigns

This engine
* Hosts email campaign definitions
* Host email templates for campaigns sent out internally
* Sends out emails or publish events that trigger emails in external tools/services
* Keeps track of all the state required to send out e-mails
* Provides APIs to let cl2-front configure it all

# Previewing emails

http://localhost:4000/rails/mailers/

MailCatcher: http://localhost:1080

# Campaign

Campaign is a class that is not intended to be used directly. It is a unified model that should be subclassed to implement specific campaign.
A campaign is a dynamic e-mail messages that can define certain logic with respect to:

- When it should be sent
- Who receives it
- What should be sent
- How it should be sent
- What should be tracked about it

## `#generate_command`

The `generate_command` method should be implemented by every campaign. It receives `time` or `activity` as options, and returns the `command` Hash that will be used to send out the campaign.
As a minimum, the command should contain the `event_payload`.

## `#mailer_class`

If the campaign should be sent out internally, instead of by publishing an event to the event bus, the ActionMailer class should be returned from the optional `mailer_class` method.

## Hooks

Every campaign subclass can make use of the following 3 hooks. Here's a minimal example:

```ruby
mpdule EmailCampaigns
class Campaigns::DemoCampaign < Campaign
  before_send :demo_content_exists?
  recipient_filter :filter_new_users
  after_send :notify_demo_api

  # ...

  private

  def demo_content_exists? options={}
    time = options[:time]
    SomeApi.new_demo_content?(at: time)
  end

  def filter_new_users users_scope, options={}
    users_scope.where("registration_completed_at > ?", Time.now - 1.week)
  end

  def after_send command

  end

end
```

### `before_send`

Registered `before_send` actions are possibly passed `time` and `activity` options, depending on how the campaign is  triggered - through a schedule or through an activity trigger.

The `before_send` actions have 2 purposes:
* Run any code that would be needed before send a campaign
* Returning a falsy value to stop the campaign from being sent out, a truthy value to continue

### `recipient_filter`

Registered `recipient_filter` actions get passed a `users_scope` object, and can potentially filter the scope to more finely specify the campaign recipients.

### `after_send`

Registered `after_send` actions get passed the command generated by `generate_command`. This can be used to do campaign-specific cleanup or tracking.


## Concerns
### ActivityTriggerable
### Consentable
Include this concern when the user should be able to consent to receiving this campaign through their user profile.

Campaigns implementing this can optionally implement the `consentable_roles` class method, returning an array of roles that are entitled to consent to this campaign. Returning an empty array, or not implementing the method, means that all users can consent.

For example:
```ruby
class SomeCampaign < Campaign
  include Consentable

  def self.consentable_roles
    ['admin', 'project_moderator']
  end
end
```

All consentable campaigns should have a category in the following list (to be kept in sync with front-end): 'own', 'admin', 'official', 'mention', 'voted', 'commented', 'weekly' as follows, so it can be displayed to the user consent form.

```ruby
def self.category
  'voted'
end
```

### ContentConfigurable
### Disableable
### RecipientConfigurable
### Schedulable
### SenderConfigurable
### Trackable


# Adding New Email Campaign (Optional: With Notifications)

## Optional: Create a Notification

1. If not yet exisiting, add a new `LogActivityJob` to the appropriate side FX service.

2. Create a notification file in `models/notifications`. Make sure to specify as many of the supported attributes (e.g. idea, comment...) as possible.

3. Create a serializer for the new notification in `serializers/web_api/v1/notifications`.

4. Add a mapping to `controllers/web_api/v1/notifications_controller.rb`.

5. Add a new factory for this type of notification.

6. Create a frontend task to support the new notification.

7. If the `make_notifications_on` method implements relatively complex logic, add a test case to `./spec/models/notification_spec.rb`.


## Add the Actual Campaign

1. Create campaign file in `engines/free/email_campaigns/app/models/email_campaigns/campaigns`. Include the desired concerns (e.g. `Consentable`, `RecipientConfigurable`, `Disableable`); `ContentConfigurable`, `SenderConfigurable` and `Trackable` only work for manual campaigns. If `Disableable` is not included, the campaign will still be listed by the frontend, but it will not be disableable. The `enabled` attribute can be set before validation to specify whether the campaign is enabled or disabled by default.

2. Add the campaign type to `delivery_service.rb`, or patch the service.

3. Add entries for the translations to `engines/free/email_campaigns/config/locales/en.yml` only.

4. Add the mailer and mjml.

6. Run `rake email_campaigns:assure_campaign_records` to test it in development.


## Update the Specs

1. Add a factory to `./engines/free/email_campaigns/spec/factories/campaigns.rb`.

2. Add a factory instance to `@campaigns` in `./engines/free/email_campaigns/spec/acceptance/consents_spec.rb`, if the campaign is consentable.
