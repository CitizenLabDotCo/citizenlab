# frozen_string_literal: true

require 'rails_helper'

RSpec.describe ClaimToken do
  describe 'factory' do
    it 'is valid' do
      # Use create because polymorphic associations require persisted records
      expect(create(:claim_token)).to be_valid
    end

    it 'creates an idea without author' do
      claim_token = create(:claim_token)
      expect(claim_token.item).to be_a(Idea)
      expect(claim_token.item.author_id).to be_nil
    end
  end

  describe 'validations' do
    let(:idea) { create(:idea, author: nil) }

    it 'requires a token' do
      # Token is auto-generated by callback, so we test that the validation exists
      claim_token = described_class.new(item: idea)
      claim_token.save # Trigger callbacks and save
      expect(claim_token.token).to be_present # Auto-generated
    end

    it 'is invalid without an item_type' do
      claim_token = described_class.new(item: idea)
      claim_token.item_type = nil
      expect(claim_token).to be_invalid
    end

    it 'is invalid without an item_id' do
      claim_token = described_class.new(item: idea)
      claim_token.item_id = nil
      expect(claim_token).to be_invalid
    end

    it 'requires an expires_at' do
      # expires_at is auto-generated by callback, so we test that it's set
      claim_token = described_class.new(item: idea)
      claim_token.save # Trigger callbacks and save
      expect(claim_token.expires_at).to be_present # Auto-generated
    end

    it 'is invalid with unsupported item_type' do
      claim_token = described_class.new(item: idea)
      claim_token.item_type = 'Comment'
      expect(claim_token).to be_invalid
    end

    it 'enforces unique token' do
      existing = create(:claim_token)
      new_token = described_class.new(item: create(:idea, author: nil), token: existing.token)
      expect(new_token).to be_invalid
    end
  end

  describe 'attribute defaults' do
    let(:idea) { create(:idea, author: nil) }

    it 'generates a UUID token on initialization' do
      claim_token = described_class.new(item: idea)
      expect(claim_token.token).to be_present
      expect(claim_token.token).to match(/\A[0-9a-f-]{36}\z/)
    end

    it 'sets expiry to 24 hours from now on initialization' do
      claim_token = described_class.new(item: idea)
      expect(claim_token.expires_at).to be_within(1.minute).of(24.hours.from_now)
    end
  end

  describe 'scopes' do
    describe '.expired' do
      it 'returns only expired tokens' do
        expired = create(:claim_token, :expired)
        valid_token = create(:claim_token)

        expect(described_class.expired).to include(expired)
        expect(described_class.expired).not_to include(valid_token)
      end
    end

    describe '.for_user' do
      it 'returns pending tokens for a specific user' do
        user = create(:user)
        other_user = create(:user)
        pending_for_user = create(:claim_token, pending_claimer: user)
        pending_for_other = create(:claim_token, pending_claimer: other_user)
        claimable = create(:claim_token)

        expect(described_class.for_user(user)).to include(pending_for_user)
        expect(described_class.for_user(user)).not_to include(pending_for_other)
        expect(described_class.for_user(user)).not_to include(claimable)
      end
    end
  end

  describe '#expired?' do
    it 'returns true for expired tokens' do
      claim_token = create(:claim_token, :expired)
      expect(claim_token.expired?).to be true
    end

    it 'returns false for valid tokens' do
      claim_token = create(:claim_token)
      expect(claim_token.expired?).to be false
    end
  end
end
